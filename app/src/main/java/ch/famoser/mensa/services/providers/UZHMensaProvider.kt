package ch.famoser.mensa.services.providers

import ch.famoser.mensa.models.Location
import ch.famoser.mensa.models.Mensa
import ch.famoser.mensa.models.Menu
import ch.famoser.mensa.services.IAssetService
import ch.famoser.mensa.services.ICacheService
import ch.famoser.mensa.services.ISerializationService
import org.jsoup.Jsoup
import org.jsoup.nodes.Element
import java.lang.reflect.ParameterizedType
import java.net.URI
import java.util.*
import kotlin.collections.ArrayList
import kotlin.collections.HashMap

abstract class UZHMensaProvider<T : UzhMensa>(
    cacheService: ICacheService,
    assetService: IAssetService,
    serializationService: ISerializationService
) : AbstractMensaProvider(cacheService, assetService, serializationService) {

    companion object {
        const val CACHE_PROVIDER_PREFIX = "uzh"
    }

    private val mensaMap: MutableMap<Mensa, T> = HashMap()

    fun getMenus(mensa: Mensa, date: Date, language: Language, ignoreCache: Boolean): Boolean {
        val uzhMensa = mensaMap[mensa]
        if (uzhMensa === null)
            throw IllegalArgumentException("You may only pass objects generated by this provider.")

        return try {
            val normalizedLanguage = languageToString(language)
            val menus: List<Menu>? = loadMenus(uzhMensa, date, normalizedLanguage, ignoreCache)

            if (menus != null) {
                mensa.replaceMenus(menus)
                true
            } else {
                false
            }
        } catch (ex: Exception) {
            ex.printStackTrace()

            false
        }
    }

    private fun loadMenus(
        uzhMensa: T,
        date: Date,
        language: String,
        ignoreCache: Boolean
    ): List<Menu>? {
        if (!ignoreCache) {
            val menus = tryGetMenusFromCache(CACHE_PROVIDER_PREFIX, uzhMensa.id, date, language)

            if (menus != null) {
                return menus
            }
        }

        val menusFromApi = loadMenusFromApi(uzhMensa, date, language)
        if (menusFromApi != null) {
            cacheMenus(CACHE_PROVIDER_PREFIX, uzhMensa.id, date, language, menusFromApi)
        }

        return menusFromApi
    }

    private fun loadMenusFromApi(
        uzhMensa: T,
        date: Date,
        language: String
    ): List<Menu>? {
        val dayOfWeek = getDayOfWeek(date)
        val apiUrl = getUrlFor(uzhMensa, dayOfWeek, language) ?: return null
        val htmlMenus = parseMensaHtml(apiUrl)

        // if only "closed" or "not available" then do not show any menus
        val realMenus = htmlMenus.filter { !isNoMenuNotice(it, language) }
        if (realMenus.isEmpty()) {
            return ArrayList()
        }

        return htmlMenus.map {
            val price = if (it.price != null) it.price!! else arrayOf()
            val title = if (it.title != null) it.title!! else ""
            val allergens = if (it.allergenInfo != null) it.allergenInfo!!.replace("\\s+".toRegex(), " ") else ""
            Menu(title, normalizeText(it.description), price, allergens)
        }
    }

    private fun isNoMenuNotice(menu: HtmlMenu, language: String): Boolean {
        when (language) {
            "en" -> {
                val invalidMenus = arrayOf("no dinner", "is closed")
                return invalidMenus.any { menu.description.contains(it) }
            }
            "de" -> {
                val invalidMenus = arrayOf("kein Abendessen", "geschlossen")
                return invalidMenus.any { menu.description.contains(it) }
            }
        }
        return false
    }

    private fun getDayOfWeek(date: Date): Int {
        val calender = Calendar.getInstance()
        calender.time = date

        return calender.get(Calendar.DAY_OF_WEEK)
    }

    protected abstract fun getUrlFor(uzhMensa: T, dayOfWeek: Int, language: String): String?

    private fun parseMensaHtml(url: String): List<HtmlMenu> {
        val doc = Jsoup.connect(url).get()
        val newslistDiv = doc.select(getContentSelector()).first()
        val contentDiv = newslistDiv.child(0)

        return parseContent(contentDiv)
    }

    protected abstract fun getContentSelector(): String

    override fun getLocations(): List<Location> {
        val fileName = "uzh/" + getLocationsJsonFileName()
        val uzhLocations =
            super.readJsonAssetFileToListOfT<UzhLocation<T>>(fileName, getParametrizedUzhLocation())

        return uzhLocations.map { uzhLocation ->
            Location(uzhLocation.title, uzhLocation.mensas.map {
                val mensa = Mensa(
                    UUID.fromString(it.id),
                    it.title,
                    it.mealTime,
                    URI("http://www.mensa.uzh.ch/de/standorte/${it.infoUrlSlug}.html")
                )
                mensaMap[mensa] = it
                mensa
            })
        }
    }

    protected abstract fun getParametrizedUzhLocation(): ParameterizedType

    protected abstract fun getLocationsJsonFileName(): String

    private fun parseContent(contentDiv: Element): ArrayList<HtmlMenu> {
        var currentMenu: HtmlMenu? = null
        val menus = ArrayList<HtmlMenu>()
        for (i in 0 until contentDiv.children().size) {
            val activeChild = contentDiv.child(i)
            val newMenu = tryCreateMenuFromHeader(activeChild)
            if (newMenu != null) {
                if (currentMenu != null) {
                    menus.add(currentMenu)
                }

                currentMenu = newMenu
            }

            tryFillContent(activeChild, currentMenu)
        }

        if (currentMenu != null) {
            menus.add(currentMenu)
        }

        return menus
    }

    private fun tryFillContent(
        activeChild: Element,
        htmlMenu: HtmlMenu?
    ) {
        if (activeChild.`is`("p") && htmlMenu != null) {
            var paragraphContent = activeChild.textNodes()
                .joinToString(separator = "\n", transform = { node -> node.wholeText.trim() })

            val allergyPrefixes = arrayOf("Allergikerinformationen:", "Allergy information:")
            val matchingPrefix = allergyPrefixes.firstOrNull { paragraphContent.startsWith(it) }
            if (matchingPrefix != null) {
                htmlMenu.allergenInfo = paragraphContent.substring(matchingPrefix.length).trim()
            } else {
                if (htmlMenu.description.isNotEmpty()) {
                    htmlMenu.description += "\n\n"
                }

                // normalize fleisch
                paragraphContent = paragraphContent.replace("Fleisch:", "\nFleisch:")
                paragraphContent = paragraphContent.replace("Fleisch :", "\nFleisch:")

                htmlMenu.description += paragraphContent.trim()
            }
        }
    }

    private fun tryCreateMenuFromHeader(activeChild: Element): HtmlMenu? {
        if (activeChild.`is`("h3")) {
            val headerText = activeChild.text()
            if (headerText.contains("|")) {
                val htmlMenu = HtmlMenu()

                //parse header of the form einfach gut | CHF 5.40 / 7.00 / 10.50
                val headerParts = headerText.split("|")
                htmlMenu.title = headerParts[0].trim()
                htmlMenu.price = headerParts[1]
                    .split("/")
                    .map { it.trim() }
                    .map {
                        if (it.startsWith("CHF")) {
                            it.substring(3).trim()
                        } else {
                            it
                        }
                    }
                    .toTypedArray()

                return htmlMenu
            }
        }

        return null
    }

    protected class HtmlMenu {
        var title: String? = null
        var price: Array<String>? = null
        var description: String = ""
        var allergenInfo: String? = null
    }
}